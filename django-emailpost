#!/usr/bin/env python

#   Copyright 2011 Josh Kearney
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

"""django-emailpost - Post to Django blogs via email."""

from __future__ import with_statement

import optparse
import os
import re
import sys

from django.conf import settings

from email import message_from_file
from email.parser import Parser


__VERSION__ = "0.0.1"
__TMP_FILE__ = "/tmp/django-emailpost.txt"


def capture_headers(msg):
    """Capture and return the email's headers."""
    subject = msg["SUBJECT"]

    # Pull the category out of the subject.
    regex = re.compile("\{(.*)\}")
    match = regex.search(subject)

    if match:
        category = match.group(1).capitalize()
        subject = subject[:-(len(category) + 2)]

        return dict(
                original_recipient=os.getenv("ORIGINAL_RECIPIENT"),
                sender=os.getenv("SENDER"),
                subject=subject.strip(),
                category=category)
    else:
        sys.exit("Must provide a category.")


def walk_email(msg, attachment_dir):
    """Walk through the email and return its body with attachments."""
    body = ""
    attachments = []

    for part in msg.walk():
        part_type = part.get_content_type()

        if part_type.startswith("image"):
            filename = part.get_filename()
            # TODO(jk0): Prevent existing files from being overwritten.
            with open(os.path.join(attachment_dir, filename), "w") as f:
                f.write(part.get_payload(decode=True))
            f.closed

            attachments.append(filename)
        elif part_type == "text/plain":
            body = part.get_payload()

    return (body, attachments)


def build_options():
    """Generate command line options."""
    parser = optparse.OptionParser(version=__VERSION__)

    parser.add_option("-a", "--app", dest="app",
            help="name of the Django app")
    parser.add_option("-m", "--model", dest="model",
            help="model of the Django app")
    parser.add_option("-p", "--project-path", dest="project_path",
            help="path to the Django project")
    parser.add_option("-r", "--recipient", dest="recipient",
            help="accepted recipient")
    parser.add_option("-s", "--sender", dest="sender",
            help="accepted sender")

    return parser.parse_args()


def ensure_config_options():
    """Ensure the required CLI options are present."""
    if not __APP__:
        sys.exit("Must supply a Django app.")
    elif not __MODEL__:
        sys.exit("Must supply an app model.")
    elif not __PROJECT_PATH__:
        sys.exit("Must supply path to Django project.")
    elif not __RECIPIENT__:
        sys.exit("Must supply a recipient.")
    elif not __SENDER__:
        sys.exit("Must supply a sender.")

    # Add the project to the Python Path while we're at it.
    sys.path.append(__PROJECT_PATH__)
    sys.path.append(__PROJECT_PATH__ + "/../")
    os.environ["DJANGO_SETTINGS_MODULE"]= "%s.settings" % os.path.basename(
            __PROJECT_PATH__)


def ensure_allowed():
    """Ensure sender is permitted to send to recipient."""
    if __SENDER__ != __HEADERS__["sender"]:
        sys.exit("Access Denied: Invalid Sender")
    elif __RECIPIENT__ != __HEADERS__["original_recipient"]:
        sys.exit("Access Denied: Invalid Recipient")


def load_models():
    """Load and return the app's models."""
    # Import this here because DJANGO_SETTINGS_MODULE needs to be set first.
    from django.db import models

    return (models.get_model(__APP__, __MODEL__),
            models.get_model(__APP__, "Category"))


def find_category(model, category):
    """Find and return the category ID."""
    try:
        return int(model.objects.filter(name=category)[0].id)
    except IndexError:
        sys.exit("Category not found.")


if __name__ == "__main__":
    OPTIONS, ARGS = build_options()

    __APP__ = OPTIONS.app
    __MODEL__ = OPTIONS.model
    __PROJECT_PATH__ = OPTIONS.project_path
    __RECIPIENT__ = OPTIONS.recipient
    __SENDER__ = OPTIONS.sender

    ensure_config_options()

    # Postfix sends messages via stdin.
    MSG = Parser().parse(sys.stdin)

    # Enforce ACLs and parse the email's headers.
    __HEADERS__ = capture_headers(MSG)
    ensure_allowed()

    # Extract email body and attachment filenames.
    BODY, ATTACHMENTS = walk_email(MSG, settings.MEDIA_ROOT)

    # Load the app's models and the category ID.
    POST_MODEL, CATEGORY_MODEL = load_models()
    CATEGORY_ID = find_category(CATEGORY_MODEL, __HEADERS__["category"])

    # Temporary debugging.
    with open(__TMP_FILE__, "w") as f:
        f.write("%s\n%s\n%s\n%s\n%s\n%s" % (
                __HEADERS__["original_recipient"], __HEADERS__["sender"],
                __HEADERS__["subject"], CATEGORY_ID, BODY, ATTACHMENTS))
    f.closed
