#!/usr/bin/env python

#   Copyright 2011 Josh Kearney
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

"""django-emailpost - Post to Django blogs via email."""

from __future__ import with_statement

import optparse
import os
import sys

from django.conf import settings

from email import message_from_file
from email.parser import Parser


__VERSION__ = "0.0.1"
__TMP_FILE__ = "/tmp/django-emailpost.txt"


def capture_headers(msg):
    """Capture and return the email's headers."""
    return dict(
            original_recipient=os.getenv("ORIGINAL_RECIPIENT"),
            sender=os.getenv("SENDER"),
            subject=msg["SUBJECT"])


def walk_email(msg, attachment_dir):
    """Walk through the email and return its body with attachments."""
    body = ""
    attachments = []

    for part in msg.walk():
        part_type = part.get_content_type()

        if part_type.startswith("image"):
            filename = part.get_filename()
            # TODO(jk0): Prevent existing files from being overwritten.
            with open(os.path.join(attachment_dir, filename), "w") as f:
                f.write(part.get_payload(decode=True))
            f.closed

            attachments.append(filename)
        elif part_type == "text/plain":
            body = part.get_payload()

    return (body, attachments)


def build_options():
    """Generate command line options."""
    parser = optparse.OptionParser(version=__VERSION__)

    parser.add_option("-m", "--model", dest="model",
            help="model of the Django app")
    parser.add_option("-p", "--project-path", dest="project_path",
            help="path of the Django project")
    parser.add_option("-r", "--recipient", dest="recipient",
            help="accepted recipient")
    parser.add_option("-s", "--sender", dest="sender",
            help="accepted sender")

    return parser.parse_args()


def ensure_config_options():
    """Ensure the required CLI options are present."""
    if not MODEL:
        sys.exit("Must supply an app model.")
    elif not PROJECT_PATH:
        sys.exit("Must supply path to Django project.")
    elif not RECIPIENT:
        sys.exit("Must supply a recipient.")
    elif not SENDER:
        sys.exit("Must supply a sender.")


def ensure_allowed(headers, sender, recipient):
    """Ensure sender is permitted to send to recipient."""
    if sender != headers["sender"]:
        sys.exit("Access Denied: Invalid Sender")
    elif recipient != headers["original_recipient"]:
        sys.exit("Access Denied: Invalid Recipient")


if __name__ == "__main__":
    OPTIONS, ARGS = build_options()

    MODEL = OPTIONS.model
    PROJECT_PATH = OPTIONS.project_path
    RECIPIENT = OPTIONS.recipient
    SENDER = OPTIONS.sender
    APP = os.path.basename(PROJECT_PATH)

    ensure_config_options()

    # Prepare Django project's env vars.
    sys.path.append(PROJECT_PATH)
    sys.path.append(PROJECT_PATH + "/../")
    os.environ["DJANGO_SETTINGS_MODULE"]= "%s.settings" % APP

    # Import this here because DJANGO_SETTINGS_MODULE needs to be set.
    from django.db import models

    # Postfix sends messages via stdin.
    MSG = Parser().parse(sys.stdin)

    # Enforce ACLs.
    HEADERS = capture_headers(MSG)
    ensure_allowed(HEADERS, SENDER, RECIPIENT)

    # Extract email body and attachments.
    BODY, ATTACHMENTS = walk_email(MSG, settings.MEDIA_ROOT)

    # TODO(jk0): post to app's MODEL and use templates for handling text-only
    # posts, single image posts and multi-image posts.
    # https://docs.djangoproject.com/en/1.3/intro/tutorial01/
    # http://djangosnippets.org/snippets/1413/

    with open(__TMP_FILE__, "w") as f:
        f.write("%s\n%s\n%s\n%s\n%s" % (
                HEADERS["original_recipient"], HEADERS["sender"],
                HEADERS["subject"], BODY, ATTACHMENTS))
    f.closed
